<x-filament-panels::page class="h-full">
    <div 
        x-data="fidoChat({
            history: @js($this->chatHistory),
            serviceUrl: '{{ $this->serviceUrl }}',
            serviceSecret: '{{ $this->serviceSecret }}'
        })"
        class="flex flex-col h-[calc(100vh-12rem)] -mt-4" 
    >
        <div 
            x-ref="chatBox"
            class="flex-1 overflow-y-auto p-4 space-y-6 bg-gray-50 dark:bg-gray-900 rounded-t-xl border border-gray-200 dark:border-gray-700 shadow-inner"
        >
            <template x-for="(msg, index) in history" :key="index">
                <div class="flex w-full" :class="msg.role === 'user' ? 'justify-end' : 'justify-start'">
                    <div class="flex max-w-[80%] gap-3" :class="msg.role === 'user' ? 'flex-row-reverse' : 'flex-row'">
                        <div class="flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center"
                             :class="msg.role === 'user' ? 'bg-primary-600' : 'bg-gray-200 dark:bg-gray-700'">
                             <template x-if="msg.role === 'user'">
                                <span class="text-xs text-white font-bold">U</span>
                             </template>
                             <template x-if="msg.role !== 'user'">
                                <x-heroicon-m-cpu-chip class="w-5 h-5 text-gray-600 dark:text-gray-300" />
                             </template>
                        </div>

                        <div class="p-4 rounded-2xl shadow-sm text-sm leading-relaxed"
                             :class="msg.role === 'user' 
                                ? 'bg-primary-600 text-white rounded-tr-none' 
                                : 'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 text-gray-800 dark:text-gray-200 rounded-tl-none'">
                            <div class="prose dark:prose-invert max-w-none" x-html="msg.parts[0].text"></div>
                        </div>
                    </div>
                </div>
            </template>

            <div x-show="loading" class="flex justify-start w-full px-12">
                <div class="bg-gray-200 dark:bg-gray-800 p-3 rounded-2xl rounded-tl-none flex space-x-1">
                    <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce"></div>
                    <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce delay-75"></div>
                    <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce delay-150"></div>
                </div>
            </div>
        </div>

        <div class="bg-white dark:bg-gray-900 border-x border-b border-gray-200 dark:border-gray-700 rounded-b-xl p-4 z-10">
            <form @submit.prevent="sendMessage" class="relative flex items-end gap-2">
                <div class="flex-grow">
                    {{ $this->form }}
                </div>
                <x-filament::button
                    type="submit"
                    icon="heroicon-m-paper-airplane"
                    class="mb-1"
                    ::disabled="loading"
                ></x-filament::button>
            </form>
            <div class="text-center text-xs text-gray-400 mt-2">
                Fido peut faire des erreurs.
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('fidoChat', (config) => ({
                history: config.history,
                loading: false,

                init() { this.scrollToBottom(); },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const box = this.$refs.chatBox;
                        if (box) box.scrollTop = box.scrollHeight;
                    });
                },

                async sendMessage() {
                    const input = document.querySelector('textarea');
                    const text = input ? input.value : '';

                    if (!text.trim() || this.loading) return;

                    if(input) input.value = '';
                    
                    this.history.push({ role: 'user', parts: [{ text: text }] });
                    this.scrollToBottom();
                    this.loading = true;

                    // Add one placeholder for the model response
                    this.history.push({ role: 'model', parts: [{ text: '' }] });
                    const idx = this.history.length - 1;

                    try {
                        const res = await fetch(config.serviceUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-fido-secret': config.serviceSecret
                            },
                            body: JSON.stringify({ prompt: text, history: this.history.slice(0, -2) })
                        });

                        if (!res.ok) throw new Error('Network error');

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk;

                            // Try parsing JSON safely
                            try {
                                const json = JSON.parse(buffer);
                                if (json?.response) {
                                    this.history[idx].parts[0].text += json.response;
                                    this.scrollToBottom();
                                }
                                if (json?.done) {
                                    buffer = ''; // Clear buffer when finished
                                }
                            } catch {
                                // Partial JSON: wait for next chunk
                            }
                        }

                        // Final save
                        @this.saveConversation(this.history);

                    } catch (e) {
                        console.error(e);
                        this.history[idx].parts[0].text = "Erreur de connexion au service IA.";
                    } finally {
                        this.loading = false;
                        this.scrollToBottom();
                    }
                }
            }))
        });
    </script>
</x-filament-panels::page>
